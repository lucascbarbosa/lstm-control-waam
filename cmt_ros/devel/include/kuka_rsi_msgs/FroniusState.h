// Generated by gencpp from file kuka_rsi_msgs/FroniusState.msg
// DO NOT EDIT!


#ifndef KUKA_RSI_MSGS_MESSAGE_FRONIUSSTATE_H
#define KUKA_RSI_MSGS_MESSAGE_FRONIUSSTATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace kuka_rsi_msgs
{
template <class ContainerAllocator>
struct FroniusState_
{
  typedef FroniusState_<ContainerAllocator> Type;

  FroniusState_()
    : header()
    , arc_voltage(0.0)
    , arc_current(0.0)
    , motor_current(0.0)
    , wire_feed_speed(0.0)
    , arc_stable(false)
    , limit_signal(false)
    , process_active(false)
    , main_current_signal(false)
    , torch_collision_protection(false)
    , power_source_ready(false)
    , communication_ready(false)
    , life_toggle_bit(false)
    , error_number(0)
    , wire_stick_control(false)
    , robot_access(false)
    , wire_available(false)
    , timeout_short_circuit(false)
    , data_documentation_ready(false)
    , power_outside_range(false)  {
    }
  FroniusState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , arc_voltage(0.0)
    , arc_current(0.0)
    , motor_current(0.0)
    , wire_feed_speed(0.0)
    , arc_stable(false)
    , limit_signal(false)
    , process_active(false)
    , main_current_signal(false)
    , torch_collision_protection(false)
    , power_source_ready(false)
    , communication_ready(false)
    , life_toggle_bit(false)
    , error_number(0)
    , wire_stick_control(false)
    , robot_access(false)
    , wire_available(false)
    , timeout_short_circuit(false)
    , data_documentation_ready(false)
    , power_outside_range(false)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef float _arc_voltage_type;
  _arc_voltage_type arc_voltage;

   typedef float _arc_current_type;
  _arc_current_type arc_current;

   typedef float _motor_current_type;
  _motor_current_type motor_current;

   typedef float _wire_feed_speed_type;
  _wire_feed_speed_type wire_feed_speed;

   typedef uint8_t _arc_stable_type;
  _arc_stable_type arc_stable;

   typedef uint8_t _limit_signal_type;
  _limit_signal_type limit_signal;

   typedef uint8_t _process_active_type;
  _process_active_type process_active;

   typedef uint8_t _main_current_signal_type;
  _main_current_signal_type main_current_signal;

   typedef uint8_t _torch_collision_protection_type;
  _torch_collision_protection_type torch_collision_protection;

   typedef uint8_t _power_source_ready_type;
  _power_source_ready_type power_source_ready;

   typedef uint8_t _communication_ready_type;
  _communication_ready_type communication_ready;

   typedef uint8_t _life_toggle_bit_type;
  _life_toggle_bit_type life_toggle_bit;

   typedef uint8_t _error_number_type;
  _error_number_type error_number;

   typedef uint8_t _wire_stick_control_type;
  _wire_stick_control_type wire_stick_control;

   typedef uint8_t _robot_access_type;
  _robot_access_type robot_access;

   typedef uint8_t _wire_available_type;
  _wire_available_type wire_available;

   typedef uint8_t _timeout_short_circuit_type;
  _timeout_short_circuit_type timeout_short_circuit;

   typedef uint8_t _data_documentation_ready_type;
  _data_documentation_ready_type data_documentation_ready;

   typedef uint8_t _power_outside_range_type;
  _power_outside_range_type power_outside_range;





  typedef boost::shared_ptr< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> const> ConstPtr;

}; // struct FroniusState_

typedef ::kuka_rsi_msgs::FroniusState_<std::allocator<void> > FroniusState;

typedef boost::shared_ptr< ::kuka_rsi_msgs::FroniusState > FroniusStatePtr;
typedef boost::shared_ptr< ::kuka_rsi_msgs::FroniusState const> FroniusStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::kuka_rsi_msgs::FroniusState_<ContainerAllocator1> & lhs, const ::kuka_rsi_msgs::FroniusState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.arc_voltage == rhs.arc_voltage &&
    lhs.arc_current == rhs.arc_current &&
    lhs.motor_current == rhs.motor_current &&
    lhs.wire_feed_speed == rhs.wire_feed_speed &&
    lhs.arc_stable == rhs.arc_stable &&
    lhs.limit_signal == rhs.limit_signal &&
    lhs.process_active == rhs.process_active &&
    lhs.main_current_signal == rhs.main_current_signal &&
    lhs.torch_collision_protection == rhs.torch_collision_protection &&
    lhs.power_source_ready == rhs.power_source_ready &&
    lhs.communication_ready == rhs.communication_ready &&
    lhs.life_toggle_bit == rhs.life_toggle_bit &&
    lhs.error_number == rhs.error_number &&
    lhs.wire_stick_control == rhs.wire_stick_control &&
    lhs.robot_access == rhs.robot_access &&
    lhs.wire_available == rhs.wire_available &&
    lhs.timeout_short_circuit == rhs.timeout_short_circuit &&
    lhs.data_documentation_ready == rhs.data_documentation_ready &&
    lhs.power_outside_range == rhs.power_outside_range;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::kuka_rsi_msgs::FroniusState_<ContainerAllocator1> & lhs, const ::kuka_rsi_msgs::FroniusState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace kuka_rsi_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "30bd5f2b575dd738b94a41edaf98cf7f";
  }

  static const char* value(const ::kuka_rsi_msgs::FroniusState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x30bd5f2b575dd738ULL;
  static const uint64_t static_value2 = 0xb94a41edaf98cf7fULL;
};

template<class ContainerAllocator>
struct DataType< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "kuka_rsi_msgs/FroniusState";
  }

  static const char* value(const ::kuka_rsi_msgs::FroniusState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"# Field 4-5\n"
"float32 arc_voltage\n"
"# Field 6-7\n"
"float32 arc_current\n"
"# Field 8\n"
"float32 motor_current\n"
"# Field 9-10\n"
"float32 wire_feed_speed\n"
"# Field 1\n"
"bool arc_stable\n"
"bool limit_signal\n"
"bool process_active\n"
"bool main_current_signal\n"
"bool torch_collision_protection\n"
"bool power_source_ready\n"
"bool communication_ready\n"
"bool life_toggle_bit\n"
"# Field 2\n"
"uint8 error_number\n"
"# Field 3\n"
"bool wire_stick_control\n"
"bool robot_access\n"
"bool wire_available\n"
"bool timeout_short_circuit\n"
"bool data_documentation_ready\n"
"bool power_outside_range\n"
"#\n"
"# Commented fields are not used in WAAM Interface (welding_display.cpp)\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::kuka_rsi_msgs::FroniusState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.arc_voltage);
      stream.next(m.arc_current);
      stream.next(m.motor_current);
      stream.next(m.wire_feed_speed);
      stream.next(m.arc_stable);
      stream.next(m.limit_signal);
      stream.next(m.process_active);
      stream.next(m.main_current_signal);
      stream.next(m.torch_collision_protection);
      stream.next(m.power_source_ready);
      stream.next(m.communication_ready);
      stream.next(m.life_toggle_bit);
      stream.next(m.error_number);
      stream.next(m.wire_stick_control);
      stream.next(m.robot_access);
      stream.next(m.wire_available);
      stream.next(m.timeout_short_circuit);
      stream.next(m.data_documentation_ready);
      stream.next(m.power_outside_range);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct FroniusState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::kuka_rsi_msgs::FroniusState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::kuka_rsi_msgs::FroniusState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "arc_voltage: ";
    Printer<float>::stream(s, indent + "  ", v.arc_voltage);
    s << indent << "arc_current: ";
    Printer<float>::stream(s, indent + "  ", v.arc_current);
    s << indent << "motor_current: ";
    Printer<float>::stream(s, indent + "  ", v.motor_current);
    s << indent << "wire_feed_speed: ";
    Printer<float>::stream(s, indent + "  ", v.wire_feed_speed);
    s << indent << "arc_stable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.arc_stable);
    s << indent << "limit_signal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.limit_signal);
    s << indent << "process_active: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.process_active);
    s << indent << "main_current_signal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.main_current_signal);
    s << indent << "torch_collision_protection: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.torch_collision_protection);
    s << indent << "power_source_ready: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.power_source_ready);
    s << indent << "communication_ready: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.communication_ready);
    s << indent << "life_toggle_bit: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.life_toggle_bit);
    s << indent << "error_number: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_number);
    s << indent << "wire_stick_control: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wire_stick_control);
    s << indent << "robot_access: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.robot_access);
    s << indent << "wire_available: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wire_available);
    s << indent << "timeout_short_circuit: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.timeout_short_circuit);
    s << indent << "data_documentation_ready: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.data_documentation_ready);
    s << indent << "power_outside_range: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.power_outside_range);
  }
};

} // namespace message_operations
} // namespace ros

#endif // KUKA_RSI_MSGS_MESSAGE_FRONIUSSTATE_H
