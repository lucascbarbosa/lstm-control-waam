// Generated by gencpp from file kuka_rsi_msgs/Fronius500iState.msg
// DO NOT EDIT!


#ifndef KUKA_RSI_MSGS_MESSAGE_FRONIUS500ISTATE_H
#define KUKA_RSI_MSGS_MESSAGE_FRONIUS500ISTATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace kuka_rsi_msgs
{
template <class ContainerAllocator>
struct Fronius500iState_
{
  typedef Fronius500iState_<ContainerAllocator> Type;

  Fronius500iState_()
    : header()
    , welding_voltage(0.0)
    , welding_current(0.0)
    , wire_feed_speed(0.0)
    , motor_current_M1(0.0)
    , motor_current_M2(0.0)
    , life_toggle_bit(false)
    , power_source_ready(false)
    , warning(false)
    , process_active(false)
    , current_flow(false)
    , arc_stable(false)
    , main_current_signal(false)
    , touch_signal(false)
    , collisionbox_active(false)
    , robot_motion_release(false)
    , wire_stick_workpiece(false)
    , short_circuit_contact_tip(false)
    , parameter_selection_internally(false)
    , characteristic_number_valid(false)
    , torch_body_gripped(false)
    , command_value_out_of_range(false)
    , correction_out_of_range(false)
    , limitsignal(false)
    , main_supply_status(false)
    , process_id(0)
    , process_str()
    , touch_signal_gas_nozzle(false)
    , twin_synchro_active(false)  {
    }
  Fronius500iState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , welding_voltage(0.0)
    , welding_current(0.0)
    , wire_feed_speed(0.0)
    , motor_current_M1(0.0)
    , motor_current_M2(0.0)
    , life_toggle_bit(false)
    , power_source_ready(false)
    , warning(false)
    , process_active(false)
    , current_flow(false)
    , arc_stable(false)
    , main_current_signal(false)
    , touch_signal(false)
    , collisionbox_active(false)
    , robot_motion_release(false)
    , wire_stick_workpiece(false)
    , short_circuit_contact_tip(false)
    , parameter_selection_internally(false)
    , characteristic_number_valid(false)
    , torch_body_gripped(false)
    , command_value_out_of_range(false)
    , correction_out_of_range(false)
    , limitsignal(false)
    , main_supply_status(false)
    , process_id(0)
    , process_str(_alloc)
    , touch_signal_gas_nozzle(false)
    , twin_synchro_active(false)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef float _welding_voltage_type;
  _welding_voltage_type welding_voltage;

   typedef float _welding_current_type;
  _welding_current_type welding_current;

   typedef float _wire_feed_speed_type;
  _wire_feed_speed_type wire_feed_speed;

   typedef float _motor_current_M1_type;
  _motor_current_M1_type motor_current_M1;

   typedef float _motor_current_M2_type;
  _motor_current_M2_type motor_current_M2;

   typedef uint8_t _life_toggle_bit_type;
  _life_toggle_bit_type life_toggle_bit;

   typedef uint8_t _power_source_ready_type;
  _power_source_ready_type power_source_ready;

   typedef uint8_t _warning_type;
  _warning_type warning;

   typedef uint8_t _process_active_type;
  _process_active_type process_active;

   typedef uint8_t _current_flow_type;
  _current_flow_type current_flow;

   typedef uint8_t _arc_stable_type;
  _arc_stable_type arc_stable;

   typedef uint8_t _main_current_signal_type;
  _main_current_signal_type main_current_signal;

   typedef uint8_t _touch_signal_type;
  _touch_signal_type touch_signal;

   typedef uint8_t _collisionbox_active_type;
  _collisionbox_active_type collisionbox_active;

   typedef uint8_t _robot_motion_release_type;
  _robot_motion_release_type robot_motion_release;

   typedef uint8_t _wire_stick_workpiece_type;
  _wire_stick_workpiece_type wire_stick_workpiece;

   typedef uint8_t _short_circuit_contact_tip_type;
  _short_circuit_contact_tip_type short_circuit_contact_tip;

   typedef uint8_t _parameter_selection_internally_type;
  _parameter_selection_internally_type parameter_selection_internally;

   typedef uint8_t _characteristic_number_valid_type;
  _characteristic_number_valid_type characteristic_number_valid;

   typedef uint8_t _torch_body_gripped_type;
  _torch_body_gripped_type torch_body_gripped;

   typedef uint8_t _command_value_out_of_range_type;
  _command_value_out_of_range_type command_value_out_of_range;

   typedef uint8_t _correction_out_of_range_type;
  _correction_out_of_range_type correction_out_of_range;

   typedef uint8_t _limitsignal_type;
  _limitsignal_type limitsignal;

   typedef uint8_t _main_supply_status_type;
  _main_supply_status_type main_supply_status;

   typedef uint8_t _process_id_type;
  _process_id_type process_id;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _process_str_type;
  _process_str_type process_str;

   typedef uint8_t _touch_signal_gas_nozzle_type;
  _touch_signal_gas_nozzle_type touch_signal_gas_nozzle;

   typedef uint8_t _twin_synchro_active_type;
  _twin_synchro_active_type twin_synchro_active;





  typedef boost::shared_ptr< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> const> ConstPtr;

}; // struct Fronius500iState_

typedef ::kuka_rsi_msgs::Fronius500iState_<std::allocator<void> > Fronius500iState;

typedef boost::shared_ptr< ::kuka_rsi_msgs::Fronius500iState > Fronius500iStatePtr;
typedef boost::shared_ptr< ::kuka_rsi_msgs::Fronius500iState const> Fronius500iStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator1> & lhs, const ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.welding_voltage == rhs.welding_voltage &&
    lhs.welding_current == rhs.welding_current &&
    lhs.wire_feed_speed == rhs.wire_feed_speed &&
    lhs.motor_current_M1 == rhs.motor_current_M1 &&
    lhs.motor_current_M2 == rhs.motor_current_M2 &&
    lhs.life_toggle_bit == rhs.life_toggle_bit &&
    lhs.power_source_ready == rhs.power_source_ready &&
    lhs.warning == rhs.warning &&
    lhs.process_active == rhs.process_active &&
    lhs.current_flow == rhs.current_flow &&
    lhs.arc_stable == rhs.arc_stable &&
    lhs.main_current_signal == rhs.main_current_signal &&
    lhs.touch_signal == rhs.touch_signal &&
    lhs.collisionbox_active == rhs.collisionbox_active &&
    lhs.robot_motion_release == rhs.robot_motion_release &&
    lhs.wire_stick_workpiece == rhs.wire_stick_workpiece &&
    lhs.short_circuit_contact_tip == rhs.short_circuit_contact_tip &&
    lhs.parameter_selection_internally == rhs.parameter_selection_internally &&
    lhs.characteristic_number_valid == rhs.characteristic_number_valid &&
    lhs.torch_body_gripped == rhs.torch_body_gripped &&
    lhs.command_value_out_of_range == rhs.command_value_out_of_range &&
    lhs.correction_out_of_range == rhs.correction_out_of_range &&
    lhs.limitsignal == rhs.limitsignal &&
    lhs.main_supply_status == rhs.main_supply_status &&
    lhs.process_id == rhs.process_id &&
    lhs.process_str == rhs.process_str &&
    lhs.touch_signal_gas_nozzle == rhs.touch_signal_gas_nozzle &&
    lhs.twin_synchro_active == rhs.twin_synchro_active;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator1> & lhs, const ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace kuka_rsi_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "4355219bc4b3af559fd32d94b33e5f02";
  }

  static const char* value(const ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x4355219bc4b3af55ULL;
  static const uint64_t static_value2 = 0x9fd32d94b33e5f02ULL;
};

template<class ContainerAllocator>
struct DataType< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "kuka_rsi_msgs/Fronius500iState";
  }

  static const char* value(const ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"# Input[4]\n"
"float32 welding_voltage\n"
"# Input[5]\n"
"float32 welding_current\n"
"# Input[6]\n"
"float32 wire_feed_speed\n"
"# Input[7]\n"
"float32 motor_current_M1\n"
"# Input[8]\n"
"float32 motor_current_M2\n"
"# Input[0]\n"
"bool life_toggle_bit # 0\n"
"bool power_source_ready # 1\n"
"bool warning # 2\n"
"bool process_active # 3\n"
"bool current_flow # 4\n"
"bool arc_stable # 5\n"
"bool main_current_signal # 6\n"
"bool touch_signal # 7\n"
"# Input[1]\n"
"bool collisionbox_active # 0\n"
"bool robot_motion_release # 1\n"
"bool wire_stick_workpiece # 2\n"
"bool short_circuit_contact_tip # 4\n"
"bool parameter_selection_internally # 5\n"
"bool characteristic_number_valid # 6\n"
"bool torch_body_gripped # 7\n"
"# Input[2]\n"
"bool command_value_out_of_range # 0\n"
"bool correction_out_of_range # 1\n"
"bool limitsignal # 3\n"
"bool main_supply_status # 6\n"
"# Input[3]\n"
"uint8 process_id # 0-4\n"
"string process_str # none\n"
"bool touch_signal_gas_nozzle # 6\n"
"bool twin_synchro_active # 7\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.welding_voltage);
      stream.next(m.welding_current);
      stream.next(m.wire_feed_speed);
      stream.next(m.motor_current_M1);
      stream.next(m.motor_current_M2);
      stream.next(m.life_toggle_bit);
      stream.next(m.power_source_ready);
      stream.next(m.warning);
      stream.next(m.process_active);
      stream.next(m.current_flow);
      stream.next(m.arc_stable);
      stream.next(m.main_current_signal);
      stream.next(m.touch_signal);
      stream.next(m.collisionbox_active);
      stream.next(m.robot_motion_release);
      stream.next(m.wire_stick_workpiece);
      stream.next(m.short_circuit_contact_tip);
      stream.next(m.parameter_selection_internally);
      stream.next(m.characteristic_number_valid);
      stream.next(m.torch_body_gripped);
      stream.next(m.command_value_out_of_range);
      stream.next(m.correction_out_of_range);
      stream.next(m.limitsignal);
      stream.next(m.main_supply_status);
      stream.next(m.process_id);
      stream.next(m.process_str);
      stream.next(m.touch_signal_gas_nozzle);
      stream.next(m.twin_synchro_active);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Fronius500iState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::kuka_rsi_msgs::Fronius500iState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "welding_voltage: ";
    Printer<float>::stream(s, indent + "  ", v.welding_voltage);
    s << indent << "welding_current: ";
    Printer<float>::stream(s, indent + "  ", v.welding_current);
    s << indent << "wire_feed_speed: ";
    Printer<float>::stream(s, indent + "  ", v.wire_feed_speed);
    s << indent << "motor_current_M1: ";
    Printer<float>::stream(s, indent + "  ", v.motor_current_M1);
    s << indent << "motor_current_M2: ";
    Printer<float>::stream(s, indent + "  ", v.motor_current_M2);
    s << indent << "life_toggle_bit: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.life_toggle_bit);
    s << indent << "power_source_ready: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.power_source_ready);
    s << indent << "warning: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.warning);
    s << indent << "process_active: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.process_active);
    s << indent << "current_flow: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.current_flow);
    s << indent << "arc_stable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.arc_stable);
    s << indent << "main_current_signal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.main_current_signal);
    s << indent << "touch_signal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.touch_signal);
    s << indent << "collisionbox_active: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.collisionbox_active);
    s << indent << "robot_motion_release: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.robot_motion_release);
    s << indent << "wire_stick_workpiece: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wire_stick_workpiece);
    s << indent << "short_circuit_contact_tip: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.short_circuit_contact_tip);
    s << indent << "parameter_selection_internally: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.parameter_selection_internally);
    s << indent << "characteristic_number_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.characteristic_number_valid);
    s << indent << "torch_body_gripped: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.torch_body_gripped);
    s << indent << "command_value_out_of_range: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.command_value_out_of_range);
    s << indent << "correction_out_of_range: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.correction_out_of_range);
    s << indent << "limitsignal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.limitsignal);
    s << indent << "main_supply_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.main_supply_status);
    s << indent << "process_id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.process_id);
    s << indent << "process_str: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.process_str);
    s << indent << "touch_signal_gas_nozzle: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.touch_signal_gas_nozzle);
    s << indent << "twin_synchro_active: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.twin_synchro_active);
  }
};

} // namespace message_operations
} // namespace ros

#endif // KUKA_RSI_MSGS_MESSAGE_FRONIUS500ISTATE_H
